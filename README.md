# 코틀린 고급

## 컬렉션

- 코틀린 표준 라이브러리는 기본 컬렉션 타입인 `List`, `Set`, `Map`을 제공한다.
- 컬렉션은 두 가지 종류로 나뉜다.
  - **불변 컬렉션**(Immutable): 읽기 전용 컬렉션
  - **가변 컬렉션**(Mutable): 삽입, 수정, 삭제와 같은 쓰기 작업이 가능한 컬렉션
- Immutable 리스트 생성
- Mutable 리스트 생성
  - `apply` 함수를 사용하면 가독성이 좋아진다.
- Immutable 세트 생성
- Mutable 세트 생성
- Immutable 맵 생성
  - `to`라는 중위 함수로 key-value구조를 전달한다.
- Mutable 맵 생성
- `컬렉션 빌더`를 사용하여 컬렉션을 생성할 수 있다.
  - buildList, buildSet, buildMap 3종류를 제공
- build 내부에선 **Mutable(가변)**이고 반환시엔 **Immutable(불변)**이다.
- 특정 구현체를 사용하고 싶은 경우, 구현체의 생성자를 사용한다.
- 코틀린의 컬렉션은 `Iterable`의 구현체이므로 순차적으로 반복이 가능하다.
- 자바에선 `forEach`를 사용하면 Iterable을 구현한 컬렉션을 반복할 수 있다.
- 또한 코틀린 표준 라이브러리에는 컬렉션 사용 시 자주 사용되는 패턴인 `forEach`, `map`, `filter`와 같은 유용한 **인라인 함수**를 제공한다.
- 자바 8의 스트림은 중간 연산자(map, filter, flatMap 등)만 사용했을 땐 아무런 동작도 하지 않는다.
  - **값을 얻고 싶다면 최종 연산자(terminal operator)를 사용해야 한다.**
- 코틀린에서는 `sequence`를 사용해 자바8 스트림과 같이 Lazy하게 동작시킬 수 있다.
  - 시퀀스 API도 최종 연산자를 사용해야 중간 연산자가 동작한다.
- 일반적으로 인라인 함수는 각각 함수가 **동작할 때마다** 조건에 맞는 컬렉션을 생성한다.
- 시퀀스 API는 각각의 함수가 동작할 때 시퀀스를 생성하고 최종 연산자를 호출할 때 `1`개의 컬렉션을 생성한다.
- 벤치마크상으로 일반적으론 인라인 함수가 빠르기 때문에 인라인 함수를 쓰고, 대량의 데이터를 다룰 때는 시퀀스 API를 사용하길 추천

## 데이터 클래스

- 데이터를 보관하거나 전달하는 목적을 가진 객체를 만들 때 사용한다.
- 데이터 클래스를 사용하면 컴파일러가 자동으로 만들어주는 함수들이 있다.
    - equals()
    - hashCode()
    - toString()
    - componentN()
    - copy()
- 기존 자바에선 주로 Lombok을 사용
    - JDK 15에서 record라는 이름으로 추가됨
- 데이터 저장을 목적으로 하는 클래스는 일반적으로 3가지 함수 toString, equals, hashCode를 재정의하는데 데이터 클래스를 사용하면 자동으로 생성해준다.
- data 키워드를 class에 사용
- 데이터 클래스의 `copy()`를 사용하면 객체의 불변성을 쉽게 유지할 수 있다.
    - 불변성이 깨졌을 때의 문제점
        - 불변성이 깨진다면 `Hash 계열 자료구조`에서 의도치 않은 버그가 발생할 수 있다.
        - 또한 유지보수 관점에서도 여러 소스에서 객체의 프로퍼티를 제 각각 변경하고 있으면 코드를 파악하는 데 어려움이 있다.
    - **멀티-스레드 환경에서 객체의 불변성을 유지하는 것은 동기화 처리를 줄여주고 안정성을 유지하기 위해 중요하다.**
    - **이런 이유로 기존 객체를 수정하는 것보다 새로운 객체로 복사해서 사용하는 것이 좋다.**
    - 원하는 프로퍼티만 변경하면서 새로운 불변 객체를 생성할 수 있다.
- `componentN`은 데이터 클래스에 정의된 프로퍼티를 순서대로 가져올 수 있다.
- **`구조분해할당`을 사용해 좀 더 쉽고 안전하게 변수를 선언할 수 있다.**

## 싱글톤과 동반객체

- 싱글톤 패턴은 클래스의 인스턴스를 하나의 `단일` 인스턴스로 제한하는 디자인 패턴이다.
- 싱글톤 패턴을 구현할 때는 몇 가지 제약사항
    - 직접 인스턴스화 하지 못하도록 생성자를 `private`으로 숨긴다.
    - `getInstance()`라는 클래스의 단일 인스턴스를 반환하는 static 메서드를 제공한다.
    - 멀티-스레드 환경에서도 **안전하게** 유일한 인스턴스를 반환해야 한다.
- 코틀린은 언어에서 `객체 선언`을 통해 싱글톤을 기본 지원한다.
    - 객체 선언은 `object` 키워드를 사용한다.
- 함수나 변수를 사용할 때는 클래스 한정자를 사용한다. (`클래스명.함수명`)
- 객체 선언을 사용하면 자바의 static 유틸리티를 대신해 쉽게 싱글톤 기반의 유틸리티를 만들 수 있다.
- `companion` 키워드를 사용해 클래스 내부에 객체 선언을 사용할 수 있다.
- 동반객체의 멤버는 object로 선언한 객체와 마찬가지로 클래스 한정자를 사용해 호출할 수 있다.
    - 동반객체는 이름을 가질 수 있다.

## 실드 클래스

- 하나의 상위 클래스 또는 인터페이스에서 하위 클래스 정의를 제한할 수 있는 방법
- **when식에서 굉장히 유용하게 쓰일 수 있다.**
- 실드 클래스는 하위 클래스를 제한 조건에 따라 정의해야 하고, 이렇게 만들어진 실드 클래스의 하위 클래스는 **컴파일러가 컴파일 시점에 판단할 수 있다.**
    - 제한 조건으로 코틀린 1.6 버전 기준 같은 패키지 또는 모듈 안에 있는 경우에만 하위 클래스를 정의할 수 있다.
- 실드 클래스로 만들면 새로운 하위 클래스가 생길 경우 when식에서 새로운 하위 클래스에 대한 처리를 해야 한다.

## 확장 함수

- 코틀린은 클래스를 상속하거나 데코레이터 패턴과 같은 디자인패턴을 사용하지 않고도 클래스를 확장할 수 있는 기능을 제공한다.
- 확장 함수 내부의 `this`는 확장의 대상이 되는 객체의 참조이다. (이러한 것을 receiver 혹은 수신자 객체라고 부른다.)
- 확장하려는 클래스에 동일한 명칭의 함수가 존재할 경우, **클래스의 멤버 변수가 우선된다.**
- 함수의 시그니처가 다른 경우는 **문제 없이 확장 기능을 사용할 수 있다. → 오버로드**
- null인 경우 내부에서 `this == null`과 같은 형태로 null 검사를 수행할 수 있다.
    - 이렇게 처리하면 널 안정성 체크 필요 없이 호출할 수 있다.

## 제네릭

- 코틀린의 클래스는 자바와 마찬가지로 `타입 파라미터`를 가질 수 있다.
- 제네릭을 사용한 클래스의 인스턴스를 만들려면 `타입 아규먼트`를 제공하면 된다.
- 또한 인자를 통해 타입 추론이 가능한 경우 타입 아규먼트를 생략할 수 있다.
- 타입 추론이 가능하기 때문에 변수의 타입에 타입 아규먼트를 추가해도 되고, 그렇지 않은 경우 타입 아규먼트를 생성자에서 추가해도 된다.
- 어떤 타입이 들어올지 알 수 없지만, 안전하게 사용하고 싶은 경우 `스타 프로젝션` 구문을 제공한다.
- 변성
    - 제네릭에서 파라미터화된 타입이 서로 어떤 관계에 있는지 설명하는 개념
    - 이펙티브 자바에선 공변성과 반공변성을 설명할 때 `PECS` 규칙을 언급한다.
        - PECS는 Producer-Extends, Consumer-Super의 약자이다.
            - 공변성은 자바 제네릭의 `extends` 키워드이고 코틀린에선 `out`
            - 반공변성은 자바 제네릭의 `super` 키워드이고 코틀린에선 `in`

## 지연 초기화

- `지연초기화`는 대상에 대한 초기화를 미뤘다가 실제 사용시점에 초기화하는 기법을 말한다.
- 초기화 과정에서 자원을 많이 쓰거나 오버헤드가 발생할 경우, 지연초기화를 사용하는 게 유리할 수 있다.
- 이때 코틀린에서 제공하는 `by lazy`를 사용하면 불변성을 유지하면서 지연초기화가 가능하다.
    - by lazy를 사용하면 사용 시점에 1회만 초기화 로직이 동작한다.
    - by lazy는 기본적으로 멀티-스레드 환경에서도 안전하게 동작하도록 설계되었다.
        - by lazy 내부에서 스레드에 대한 동기화 처리를 해주기 때문이다.
        - 기본 모드는 `LazyThreadSafetyMode.SYNCHRONIZED`와 동일하다.
        - 멀티-스레드 환경이 아닌 경우에는 **동기화 작업이 오버헤드가 될 수 있으므로**  `NONE` 모드를 사용하고
        - 멀티-스레드 환경이어도 **동기화가 필요하지 않은 경우라면** `PUBLICATION` 모드를 사용
- 가변 프로퍼티에 대한 지연초기화가 필요한 경우 `lateinit`를 사용
    - lateinit을 사용할 땐 가변 변수여야 한다.
    - val인 경우 컴파일 오류가 발생하며 lateinit을 이용한 경우엔 항상 non-null이다.
    - 초기화 여부를 파악하고 사용하려면 `isInitialized` 프로퍼티를 사용하라.
    - isInitialized는 내부에선 사용할 수 있지만 외부에선 사용할 수 없다.

## 페어와 구조분해할당

1. 코틀린은 `Pair(페어)`를 통해 2개의 요소가 있는 튜플을 기본 제공한다.
    1. 첫 번째 인자는 `first`, 두 번째 인자는 `second`로 사용할 수 있다.
    2. 페어는 불변이다.
    3. 내부 코드가 데이터클래스 기반이므로 copy, componentN 함수도 기본 제공한다.
    4. `toList`를 사용해 요소를 불변 리스트로 만들 수 있다.
2. 페어가 2개의 요소를 가질 수 있다면 `Triple(트리플)`은 3개의 요소를 가질 수 있는 튜플이다.
    1. 첫 번째 인자는 `first`, 두 번째 인자는 `second`, 세 번째 인자는 `third`를 사용할 수 있다.
    2. 페어의 모든 특성을 동일하게 가지고 있다.
3. **구조분해할당을 사용하면 값을 분해해서 한 번에 여러 변수를 초기화할 수 있다.**
    1. 구조분해할당은 컴파일러 내부에서 componentN 함수를 사용한다.
    2. **배열 또는 리스트에서도 구조분해할당을 사용할 수 있다.**
        1. 다만 배열이나 리스트는 데이터가 무한정 존재할 수 있으므로 componentN은 앞선 5개 요소에 대해서만 제공한다.
    3. map의 구조분해할당은 for loop에서도 유용하게 사용된다.
        1. key-value를 쉽게 꺼내 쓸 수 있다.
        2. map을 초기화할 때 사용하는 `to`는 내부적으로 페어를 사용하기 때문에 to 대신 Pair로 작성할 수도 있다.

## 스코프 함수

1. 코틀린의 표준 라이브러리에는 객체의 컨텍스트 내에서 코드 블럭을 실행하기 위해서만 존재하는 몇 가지 함수가 포함되어 있는데 이를 `스코프 함수`라고 부른다.
2. **스코프 함수를 제대로 사용하면 불필요한 변수 선언이 없어지며, 코드를 더 간결하고 읽기 쉽게 만든다.**
3. 스코프 함수의 코드 블럭 내부에서는 변수명을 사용하지 않고도 객체에 접근할 수 있는데 그 이유는 수신자 객체에 접근할 수 있기 때문이다.
    1. 수신자 객체는 람다식 내부에서 사용할 수 있는 객체의 참조이다.
4.  스코프 함수를 사용하면 수신자 객체에 대한 참조로 `this` 또는 `it`을 사용한다.
5. **let**: null이 아닌 경우, 사용될 로직을 작성하고 새로운 결과를 반환하고 싶을 때 사용
    1. 함수의 결과를 반환 (let 함수 내부의 마지막 코드가 결과로 반환)
    2. let을 쓸 때 호출이 중첩되면 코드가 복잡해지므로 이런 경우엔 if를 사용하는 편이 낫다.
6. **run**: 수신 객체의 프로퍼티를 구성하거나 새로운 결과를 반환하고 싶을 때
    1. let을 사용할 순 있으나 내부에서 it을 사용하기 때문에 코드 중복으로 불편
7. **with**: 결과 반환 없이 내부에서 수신 객체를 이용해 다른 함수를 호출하고 싶을 때 사용
    1. let이나 run같이 함수의 결과가 반환된다.
    2. 다른 스코프 함수와 다른 점은 with는 확장 함수가 아니다.
8. **apply**: 수신 객체의 프로퍼티를 구성하고, 수신 객체를 그대로 결과로 반환하고 싶을 때 사용
    1. let, run, with는 함수의 결과가 반환타입으로 변환되는데 반해서, apply는 수신 객체 그대로 반환된다.
9. **also**: 부수 작업을 수행하고 전달받은 수신 객체를 그대로 결과로 반환하고 싶을 때 사용
10. 스코프 함수 사용 시 유의할 점
    1. 이와 같은 스코프 함수는 모두 기능이 유사하기 때문에 실무에선 섞어 쓰는 경우도 많다.
    2. this는 키워드이다.
        1. 키워드는 사전에 정의된 예약어이기 때문에 다른 의미로 사용할 수 없지만, it은 특정 용도에서만 작동하는 소프트 키워드이기 때문에 다른 용도로 사용할 수 있다.
    3. 중첩으로 사용하는 경우 this, it에 대해 혼동하기 쉽다.
    4. 또한 중첩 함수 내에서 외부 함수에 대한 접근을 하려면 it은 자기 자신의 참조이기 때문에 불가능하다.

## 고급 예외처리

1. Java7부터 제공하는 `try-with-resources` 구문을 사용하면 자동으로 리소스를 close 처리해준다.
    1. 정확히는 `Closeable` 또는 상위 개념인 `AutoCloseable` 인터페이스의 구현체에 대해서 자동으로 close 메서드를 호출한다.
2. 코틀린은 try-catch-resources 구문을 제공하지 않지만, `use`라는 확장 함수를 제공한다.
3. runCatching을 사용해 우아하게 예외처리하기
    1. 코틀린은 try-catching를 통한 예외처리 외에도 함수형 스타일의 **Result 패턴**을 구현한 `runCatching`을 제공한다.
4. Result 패턴이란?
    1. 함수가 성공하면 캡슐화된 결과를 반환하거나 예외가 발생하면 지정한 작업을 수행하는 패턴이다.
5. Result의 다양한 기능들
    1. **getOrNull**: 실패인 경우 null을 반환
    2. **exceptionOrNull**: 성공인 경우 null을 반환하고 실패인 경우 Throwable을 반환
    3. **getOrDefault**: 성공 시엔 성공값을 반환하고 실패 시엔 지정한 기본값을 반환
    4. **getOrElse**: 실패 시 수신자 객체로 Throwable을 전달받고, let, run과 같이 함수의 결과를 반환한다.
    5. **getOrThrow**: 성공 시엔 값을 반환, 실패 시엔 예외를 발생시킨다.
    6. **map**: 성공인 경우 원하는 값으로 변경할 수 있다.
    7. **mapCatching**: map처럼 성공인 경우 원하는 값으로 변경할 수 있다. 예외가 발생하면 재처리 가능
    8. **recover**: map은 성공 시에 원하는 값으로 변경하지만, recover는 실패 시에 원하는 값으로 변경할 수 있다.
    9. **recoverCatching**: recoverCatching 내에서 예외가 발생한 경우 재처리 가능
