# 코틀린 고급

1. 컬렉션
   - 코틀린 표준 라이브러리는 기본 컬렉션 타입인 `List`, `Set`, `Map`을 제공한다.
   - 컬렉션은 두 가지 종류로 나뉜다.
     - **불변 컬렉션**(Immutable): 읽기 전용 컬렉션
     - **가변 컬렉션**(Mutable): 삽입, 수정, 삭제와 같은 쓰기 작업이 가능한 컬렉션
   - Immutable 리스트 생성
   - Mutable 리스트 생성
     - `apply` 함수를 사용하면 가독성이 좋아진다.
   - Immutable 세트 생성
   - Mutable 세트 생성
   - Immutable 맵 생성
     - `to`라는 중위 함수로 key-value구조를 전달한다.
   - Mutable 맵 생성
   - `컬렉션 빌더`를 사용하여 컬렉션을 생성할 수 있다.
     - buildList, buildSet, buildMap 3종류를 제공
   - build 내부에선 **Mutable(가변)**이고 반환시엔 **Immutalbe(불변)**이다.
   - 특정 구현체를 사용하고 싶은 경우, 구현체의 생성자를 사용한다.
   - 코틀린의 컬렉션은 `Iterable`의 구현체이므로 순차적으로 반복이 가능하다.
   - 자바에선 `forEach`를 사용하면 Iterable을 구현한 컬렉션을 반복할 수 있다.
   - 또한 코틀린 표준 라이브러리에는 컬렉션 사용 시 자주 사용되는 패턴인 `forEach`, `map`, `filter`와 같은 유용한 **인라인 함수**를 제공한다.
   - 자바 8의 스트림은 중간 연산자(map, filter, flatMap 등)만 사용했을 땐 아무런 동작도 하지 않는다.
     - **값을 얻고 싶다면 최종 연산자(terminal operator)를 사용해야 한다.**
   - 코틀린에서는 `sequence`를 사용해 자바8 스트림과 같이 Lazy하게 동작시킬 수 있다.
     - 시퀀스 API도 최종 연산자를 사용해야 중간 연산자가 동작한다.
   - 일반적으로 인라인 함수는 각각 함수가 **동작할 때마다** 조건에 맞는 컬렉션을 생성한다.
   - 시퀀스 API는 각각의 함수가 동작할 때 시퀀스를 생성하고 최종 연산자를 호출할 때 `1`개의 컬렉션을 생성한다.
   - 벤치마크상으로 일반적으론 인라인 함수가 빠르기 때문에 인라인 함수를 쓰고, 대량의 데이터를 다룰 때는 시퀀스 API를 사용하길 추천
2. 데이터 클래스
   - 데이터를 보관하거나 전달하는 목적을 가진 객체를 만들 때 사용한다.
   - 데이터 클래스를 사용하면 컴파일러가 자동으로 만들어주는 함수들이 있다.
       - equals()
       - hashCode()
       - toString()
       - componentN()
       - copy()
   - 기존 자바에선 주로 Lombok을 사용
       - JDK 15에서 record라는 이름으로 추가됨
   - 데이터 저장을 목적으로 하는 클래스는 일반적으로 3가지 함수 toString, equals, hashCode를 재정의하는데 데이터 클래스를 사용하면 자동으로 생성해준다.
   - data 키워드를 class에 사용
   - 데이터 클래스의 `copy()`를 사용하면 객체의 불변성을 쉽게 유지할 수 있다.
       - 불변성이 깨졌을 때의 문제점
           - 불변성이 깨진다면 `Hash 계열 자료구조`에서 의도치 않은 버그가 발생할 수 있다.
           - 또한 유지보수 관점에서도 여러 소스에서 객체의 프로퍼티를 제 각각 변경하고 있으면 코드를 파악하는 데 어려움이 있다.
       - **멀티-스레드 환경에서 객체의 불변성을 유지하는 것은 동기화 처리를 줄여주고 안정성을 유지하기 위해 중요하다.**
       - **이런 이유로 기존 객체를 수정하는 것보다 새로운 객체로 복사해서 사용하는 것이 좋다.**
       - 원하는 프로퍼티만 변경하면서 새로운 불변 객체를 생성할 수 있다.
   - `componentN`은 데이터 클래스에 정의된 프로퍼티를 순서대로 가져올 수 있다.
   - **`구조분해할당`을 사용해 좀 더 쉽고 안전하게 변수를 선언할 수 있다.**
3. 싱글톤과 동반객체
   - 싱글톤 패턴은 클래스의 인스턴스를 하나의 `단일` 인스턴스로 제한하는 디자인 패턴이다.
   - 싱글톤 패턴을 구현할 때는 몇 가지 제약사항
       - 직접 인스턴스화 하지 못하도록 생성자를 `private`으로 숨긴다.
       - `getInstance()`라는 클래스의 단일 인스턴스를 반환하는 static 메서드를 제공한다.
       - 멀티-스레드 환경에서도 **안전하게** 유일한 인스턴스를 반환해야 한다.
   - 코틀린은 언어에서 `객체 선언`을 통해 싱글톤을 기본 지원한다.
       - 객체 선언은 `object` 키워드를 사용한다.
   - 함수나 변수를 사용할 때는 클래스 한정자를 사용한다. (`클래스명.함수명`)
   - 객체 선언을 사용하면 자바의 static 유틸리티를 대신해 쉽게 싱글톤 기반의 유틸리티를 만들 수 있다.
   - `companion` 키워드를 사용해 클래스 내부에 객체 선언을 사용할 수 있다.
   - 동반객체의 멤버는 object로 선언한 객체와 마찬가지로 클래스 한정자를 사용해 호출할 수 있다.
       - 동반객체는 이름을 가질 수 있다.
4. 실드 클래스
   - 하나의 상위 클래스 또는 인터페이스에서 하위 클래스 정의를 제한할 수 있는 방법
   - **when식에서 굉장히 유용하게 쓰일 수 있다.**
   - 실드 클래스는 하위 클래스를 제한 조건에 따라 정의해야 하고, 이렇게 만들어진 실드 클래스의 하위 클래스는 **컴파일러가 컴파일 시점에 판단할 수 있다.**
       - 제한 조건으로 코틀린 1.6 버전 기준 같은 패키지 또는 모듈 안에 있는 경우에만 하위 클래스를 정의할 수 있다.
   - 실드 클래스로 만들면 새로운 하위 클래스가 생길 경우 when식에서 새로운 하위 클래스에 대한 처리를 해야 한다.